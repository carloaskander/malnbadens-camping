import { createClient } from '@supabase/supabase-js';
import OpenAI from 'openai';

// Initialize clients
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_ANON_KEY
);

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Simple rate limiting store - no personal data
const sessionLimitStore = new Map();

// Basic rate limiting configuration
const RATE_LIMITS = {
  REQUESTS_PER_WINDOW: 10,
  WINDOW_DURATION: 10 * 60 * 1000, // 10 minutes
  BURST_REQUESTS: 5,
  BURST_WINDOW: 60 * 1000, // 1 minute
};

// Content filtering patterns - Only block clearly inappropriate content
const SUSPICIOUS_PATTERNS = [
  /(.)\1{15,}/, // Very long repeated characters (15+)
  /^[^a-zA-Z√•√§√∂√Ö√Ñ√ñ\s]*$/, // Only symbols/numbers, no letters or spaces
  
  // Enhanced profanity detection (Swedish + English)
  /fuck|shit|damn|bitch|ass|hell|crap/i,
  /fan|skit|helvete|j√§vla|kuk|fitta|hora/i,
  
  // Clear nonsense/spam
  /qwerty|asdf|zxcv/i, // Keyboard mashing
  /^(a{5,}|b{5,}|c{5,}|hej{3,}|hello{3,})$/i, // Excessive repetition
];

function getSessionId() {
  // Generate random session ID - no personal data
  return Math.random().toString(36).substring(2, 15);
}

function checkRateLimit(message) {
  const now = Date.now();
  
  // Simple session-based rate limiting
  const sessionId = 'anonymous'; // All users share same basic limits
  
  // Initialize or get rate limit data
  if (!sessionLimitStore.has(sessionId)) {
    sessionLimitStore.set(sessionId, {
      requests: [],
      recentMessages: []
    });
  }
  
  const sessionData = sessionLimitStore.get(sessionId);
  
  // Clean old requests
  sessionData.requests = sessionData.requests.filter(time => now - time < RATE_LIMITS.WINDOW_DURATION);
  
  // Check main rate limit
  if (sessionData.requests.length >= RATE_LIMITS.REQUESTS_PER_WINDOW) {
    return {
      allowed: false,
      reason: 'Rate limit exceeded'
    };
  }
  
  // Check burst protection
  const recentRequests = sessionData.requests.filter(time => now - time < RATE_LIMITS.BURST_WINDOW);
  if (recentRequests.length >= RATE_LIMITS.BURST_REQUESTS) {
    return {
      allowed: false,
      reason: 'Too many requests in short time'
    };
  }
  
  // Check message length
  if (message.length < 2 || message.length > 500) {
    return {
      allowed: false,
      reason: 'Invalid message format'
    };
  }
  
  // Check for suspicious patterns
  for (const pattern of SUSPICIOUS_PATTERNS) {
    if (pattern.test(message)) {
      return {
        allowed: false,
        reason: 'Message contains suspicious content'
      };
    }
  }
  
  // Check for repeated identical messages
  sessionData.recentMessages = sessionData.recentMessages.filter(
    msg => now - msg.timestamp < 5 * 60 * 1000 // Keep last 5 minutes
  );
  
  const identicalCount = sessionData.recentMessages.filter(
    msg => msg.text.toLowerCase() === message.toLowerCase()
  ).length;
  
  if (identicalCount >= 2) {
    return {
      allowed: false,
      reason: 'Too many identical messages'
    };
  }
  
  // Update counters
  sessionData.requests.push(now);
  sessionData.recentMessages.push({
    text: message,
    timestamp: now
  });
  
  return { allowed: true };
}

// Fallback FAQ for when API is down
const FALLBACK_FAQ = `
Hej! Jag √§r Campy Bot och √§r tillf√§lligt otillg√§nglig, men h√§r √§r grundl√§ggande information om Malnbadens Camping:

üìç **Plats**: Malnv√§gen 34, Hudiksvall - vacker naturmilj√∂ vid vattnet
üèïÔ∏è **Bokning**: Bes√∂k v√•r hemsida f√∂r aktuella priser och tillg√§nglighet
üïê **Information**: Kolla hemsidan f√∂r √∂ppettider och alla aktiviteter
üå≤ **Aktiviteter**: Simning, fiske, vandring och mycket mer

Bes√∂k v√•r hemsida f√∂r komplett information och bokning!
`;

async function searchFAQ(query) {
  try {
    // Generate embedding for the query
    const embeddingResponse = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: query,
    });
    
    const queryEmbedding = embeddingResponse.data[0].embedding;
    
    // Search for similar FAQs using cosine similarity
    const { data, error } = await supabase.rpc('match_faq', {
      query_embedding: queryEmbedding,
      match_threshold: 0.6,
      match_count: 3
    });
    
    if (error) {
      console.error('Supabase search error:', error);
      return { results: [], bestSimilarity: 0 };
    }
    
    const bestSimilarity = data.length > 0 ? data[0].similarity : 0;
    
    return {
      results: data,
      bestSimilarity
    };
  } catch (error) {
    console.error('Search FAQ error:', error);
    return { results: [], bestSimilarity: 0 };
  }
}

async function logPendingQuestion(question, anonymous) {
  try {
    console.log('üîÑ Attempting to log pending question:', question);
    const result = await supabase
      .from('pending')
      .insert([
        {
          question: question
        }
      ]);
    
    if (result.error) {
      console.error('‚ùå Supabase insertion failed:', result.error);
    } else {
      console.log('‚úÖ Successfully logged pending question');
    }
  } catch (error) {
    console.error('‚ùå Error logging pending question:', error);
  }
}

export default async function handler(req, res) {
  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }
  
  try {
    const { message } = req.body;
    
    // Validate message
    if (!message || typeof message !== 'string' || message.trim().length === 0) {
      return res.status(400).json({ error: 'Meddelande kr√§vs' });
    }
    
    const trimmedMessage = message.trim();
    
    // Check rate limits and abuse protection
    const rateLimitResult = checkRateLimit(trimmedMessage);
    if (!rateLimitResult.allowed) {
      return res.status(429).json({ 
        error: 'Hoppsan! Du har skickat m√•nga meddelanden nyligen. Vila lite och f√∂rs√∂k igen om en stund. üòä',
        fallback: FALLBACK_FAQ,
        reason: rateLimitResult.reason
      });
    }
    
    // Search for relevant FAQ entries
    const { results, bestSimilarity } = await searchFAQ(trimmedMessage);
    
    // Replace the direct response logic with multilingual support
    if (bestSimilarity >= 0.82 && results.length > 0) {
      // For high-confidence matches, use AI to translate the answer to user's language
      const directAnswerPrompt = `Du √§r Campy Bot, en hj√§lpsam AI-assistent f√∂r Malnbadens Camping. Du har hittat det perfekta svaret p√• anv√§ndarens fr√•ga.

INSTRUKTIONER:
- Svara p√• samma spr√•k som anv√§ndaren fr√•gade p√•
- Anv√§nd den exakta informationen fr√•n FAQ-svaret nedan
- H√•ll samma ton och stil som FAQ-svaret
- L√§gg INTE till extra information eller telefonnummer

FAQ SVAR:
${results[0].answer}

ANV√ÑNDARENS FR√ÖGA: ${trimmedMessage}

Ge det exakta svaret p√• anv√§ndarens spr√•k:`;

      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: directAnswerPrompt }
        ],
        temperature: 0.1,
        max_tokens: 200,
      });

      return res.status(200).json({
        response: completion.choices[0].message.content,
        confidence: 'high',
        similarity: bestSimilarity
      });
    }
    
    // Log question as potentially unanswered for learning
    await logPendingQuestion(trimmedMessage, 'anonymous');
    
    // Use GPT-4o-mini with context from search results
    const context = results.length > 0 
      ? results.map(r => `Q: ${r.question}\nA: ${r.answer}`).join('\n\n')
      : 'Ingen relevant information hittad i kunskapsdatabasen.';
    
    const systemPrompt = `Du √§r Campy Bot, en hj√§lpsam AI-assistent f√∂r Malnbadens Camping i Hudiksvall, Sverige. Du √§r h√§r f√∂r att hj√§lpa bes√∂kare med information om campingen.

üö® VIKTIGT - SPR√ÖK: Svara ALLTID p√• samma spr√•k som anv√§ndaren fr√•gade p√•. Om anv√§ndaren fr√•gar p√• engelska, svara p√• engelska. Om p√• tyska, svara p√• tyska. Anv√§nd exakt samma spr√•k som fr√•gan √§r skriven p√•!

INSTRUKTIONER:
- Anv√§nd CONTEXT nedan som prim√§r informationsk√§lla
- Om CONTEXT inte har exakt information, f√∂rs√∂k hj√§lpa baserat p√• allm√§n camping-kunskap
- F√∂r specifika detaljer som priser, bokningar eller aktuella √∂ppettider, h√§nvisa till hemsidan
- Var v√§nlig, naturlig och hj√§lpsam - prata som en riktig person
- H√•ll svaren korta men informativa (2-4 meningar)
- SVARA P√Ö SAMMA SPR√ÖK SOM ANV√ÑNDAREN FR√ÖGADE P√Ö
- Undvik att ge telefonnummer - h√§nvisa till hemsidan ist√§llet

CAMPING-RELATERADE √ÑMNEN (f√∂rs√∂k alltid hj√§lpa med dessa):
- Boende: stugor, hostel, campingplatser, faciliteter
- Aktiviteter: simning, fiske, vandring, cykling, kl√§ttring, √§ventyr, sport
- Barn & familj: lekplatser, barnaktiviteter, familjeaktiviteter
- Praktiskt: parkering, mat, shopping, transport, v√§der, s√§kerhet
- Omr√•de: Hudiksvall, n√§rliggande attraktioner, natur, str√§nder
- S√§song: √∂ppettider, bokningar, priser, tillg√§nglighet

INNEH√ÖLLSFILTRERING (endast f√∂r helt irrelevanta fr√•gor):
- Om fr√•gan handlar om helt andra √§mnen (politik, sport, teknik, skola som inte r√∂r camping), svara: "Jag √§r Campy Bot och hj√§lper med fr√•gor om Malnbadens Camping. Har du n√•gra fr√•gor om v√•r camping?"
- Vid ol√§mpligt inneh√•ll, svara professionellt: "Jag kan bara hj√§lpa med fr√•gor om campingen. Vad kan jag ber√§tta om v√•ra faciliteter?"
- N√§r du √§r os√§ker om n√•got √§r camping-relaterat, f√∂rs√∂k √§nd√• hj√§lpa genom att koppla det till camping

üö® P√ÖMINNELSE: Matcha spr√•ket i anv√§ndarens fr√•ga exakt. Engelska fr√•ga = engelskt svar. Tyskt fr√•ga = tyskt svar.

CONTEXT:
${context}`;

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: trimmedMessage }
      ],
      temperature: 0.2,
      max_tokens: 300,
    });
    
    const response = completion.choices[0].message.content;
    
    return res.status(200).json({
      response,
      confidence: bestSimilarity >= 0.6 ? 'medium' : 'low',
      similarity: bestSimilarity
    });
    
  } catch (error) {
    console.error('Chat API error:', error);
    
    // If OpenAI quota exceeded or other API errors, return fallback
    if (error.status === 429 || error.code === 'insufficient_quota') {
      return res.status(503).json({
        error: 'AI-tj√§nsten √§r tillf√§lligt otillg√§nglig',
        fallback: FALLBACK_FAQ
      });
    }
    
    return res.status(500).json({
      error: 'Ett fel uppstod. F√∂rs√∂k igen senare.',
      fallback: FALLBACK_FAQ
    });
  }
} 